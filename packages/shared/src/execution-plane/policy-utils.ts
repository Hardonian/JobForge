/**
 * JobForge Execution Plane - Policy Token Utilities
 * Token generation and validation for write action authorization
 */

import { JOBFORGE_POLICY_TOKEN_SECRET, JOBFORGE_POLICY_TOKEN_EXPIRY_HOURS } from '../feature-flags'
import type { PolicyToken, PolicyCheckResult, ValidatePolicyTokenParams } from './policy'

/**
 * Generate a policy token for write actions
 * Note: This is a client-side helper. In production, tokens should be
 * generated by a secure authorization service.
 */
export function generatePolicyToken(params: {
  tenantId: string
  actorId: string
  action: string
  scopes: string[]
  projectId?: string
  resource?: string
  context?: Record<string, unknown>
  expiresInHours?: number
}): string {
  if (!JOBFORGE_POLICY_TOKEN_SECRET) {
    throw new Error('Cannot generate policy token: JOBFORGE_POLICY_TOKEN_SECRET is not set')
  }

  const issuedAt = new Date().toISOString()
  const expiresAt = new Date(
    Date.now() + (params.expiresInHours || JOBFORGE_POLICY_TOKEN_EXPIRY_HOURS) * 60 * 60 * 1000
  ).toISOString()

  const token: Omit<PolicyToken, 'signature'> = {
    id: generateTokenId(),
    version: '1.0',
    issued_at: issuedAt,
    expires_at: expiresAt,
    tenant_id: params.tenantId,
    project_id: params.projectId,
    actor_id: params.actorId,
    scopes: params.scopes,
    action: params.action,
    resource: params.resource,
    context: params.context,
  }

  // Create signature (in production, use HMAC or RSA)
  const signature = createSignature(token)

  const fullToken: PolicyToken = {
    ...token,
    signature,
  }

  // Encode to base64 for transmission
  return encodeToken(fullToken)
}

/**
 * Validate a policy token
 */
export function validatePolicyToken(params: ValidatePolicyTokenParams): PolicyCheckResult {
  try {
    // Decode token
    const token = decodeToken(params.token)

    // Verify tenant match
    if (token.tenant_id !== params.tenantId) {
      return {
        allowed: false,
        reason: 'Token tenant mismatch',
        token_id: token.id,
        verified_scopes: [],
      }
    }

    // Verify project match (if specified)
    if (params.projectId && token.project_id !== params.projectId) {
      return {
        allowed: false,
        reason: 'Token project mismatch',
        token_id: token.id,
        verified_scopes: [],
      }
    }

    // Verify actor match (if specified)
    if (params.actorId && token.actor_id !== params.actorId) {
      return {
        allowed: false,
        reason: 'Token actor mismatch',
        token_id: token.id,
        verified_scopes: [],
      }
    }

    // Check expiration
    if (token.expires_at && new Date(token.expires_at) < new Date()) {
      return {
        allowed: false,
        reason: 'Token expired',
        token_id: token.id,
        verified_scopes: [],
      }
    }

    // Verify action match
    if (token.action !== params.action) {
      return {
        allowed: false,
        reason: `Token action mismatch: expected ${params.action}, got ${token.action}`,
        token_id: token.id,
        verified_scopes: [],
      }
    }

    // Verify signature
    if (!verifySignature(token)) {
      return {
        allowed: false,
        reason: 'Invalid token signature',
        token_id: token.id,
        verified_scopes: [],
      }
    }

    // Check required scopes
    const grantedScopes = new Set(token.scopes)
    const missingScopes = params.requiredScopes.filter((scope) => !grantedScopes.has(scope))

    if (missingScopes.length > 0) {
      return {
        allowed: false,
        reason: `Missing required scopes: ${missingScopes.join(', ')}`,
        token_id: token.id,
        verified_scopes: token.scopes,
        missing_scopes: missingScopes,
      }
    }

    return {
      allowed: true,
      token_id: token.id,
      verified_scopes: token.scopes,
    }
  } catch (error) {
    return {
      allowed: false,
      reason: `Token validation error: ${error instanceof Error ? error.message : 'Unknown error'}`,
      verified_scopes: [],
    }
  }
}

/**
 * Redact sensitive fields from a payload
 */
export function redactPayload(
  payload: Record<string, unknown>,
  fieldsToRedact: string[]
): Record<string, unknown> {
  const redacted = { ...payload }

  for (const field of fieldsToRedact) {
    if (field in redacted) {
      redacted[field] = '[REDACTED]'
    }

    // Handle nested paths (e.g., 'user.email')
    const parts = field.split('.')
    if (parts.length > 1) {
      let current: Record<string, unknown> | unknown = redacted
      for (let i = 0; i < parts.length - 1; i++) {
        if (typeof current === 'object' && current !== null && parts[i] in current) {
          current = (current as Record<string, unknown>)[parts[i]]
        } else {
          current = null
          break
        }
      }
      if (typeof current === 'object' && current !== null && parts[parts.length - 1] in current) {
        ;(current as Record<string, unknown>)[parts[parts.length - 1]] = '[REDACTED]'
      }
    }
  }

  return redacted
}

/**
 * Generate a unique token ID
 */
function generateTokenId(): string {
  return `pt_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`
}

/**
 * Create HMAC signature for token
 * Note: In production, use a proper crypto library
 */
function createSignature(token: Omit<PolicyToken, 'signature'>): string {
  // This is a placeholder implementation
  // In production, use crypto.createHmac or Web Crypto API
  const data = `${token.id}:${token.tenant_id}:${token.actor_id}:${token.action}:${token.issued_at}`
  return `sig_${btoa(data + JOBFORGE_POLICY_TOKEN_SECRET).substring(0, 32)}`
}

/**
 * Verify token signature
 */
function verifySignature(token: PolicyToken): boolean {
  // Recreate signature and compare
  const { signature, ...tokenWithoutSig } = token
  const expectedSig = createSignature(tokenWithoutSig)
  return signature === expectedSig
}

/**
 * Encode token to base64 string
 */
function encodeToken(token: PolicyToken): string {
  const json = JSON.stringify(token)
  // Use Buffer in Node.js, btoa in browser
  if (typeof Buffer !== 'undefined') {
    return Buffer.from(json).toString('base64')
  }
  return btoa(json)
}

/**
 * Decode token from base64 string
 */
function decodeToken(tokenString: string): PolicyToken {
  try {
    // Use Buffer in Node.js, atob in browser
    let json: string
    if (typeof Buffer !== 'undefined') {
      json = Buffer.from(tokenString, 'base64').toString('utf-8')
    } else {
      json = atob(tokenString)
    }
    return JSON.parse(json) as PolicyToken
  } catch {
    throw new Error('Invalid token format')
  }
}
