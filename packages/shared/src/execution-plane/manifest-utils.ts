/**
 * JobForge Execution Plane - Manifest Utilities
 * Manifest generation and rendering
 */

import type {
  ArtifactManifest,
  ArtifactOutput,
  RunMetrics,
  EnvFingerprint,
  ToolVersions,
  ManifestReportOptions,
} from './manifests'

/**
 * Generate environment fingerprint
 */
export function generateEnvFingerprint(): EnvFingerprint {
  const fingerprint: EnvFingerprint = {}

  // Node.js environment
  if (typeof process !== 'undefined') {
    fingerprint.os = process.platform
    fingerprint.arch = process.arch
    fingerprint.node_version = process.version
  }

  // Python environment (if available)
  // This would be populated by Python workers

  return fingerprint
}

/**
 * Generate tool versions
 */
export function generateToolVersions(): ToolVersions {
  return {
    jobforge: '0.2.0',
    connectors: {
      http: '1.0.0',
      webhook: '1.0.0',
      report: '1.0.0',
    },
  }
}

/**
 * Calculate run metrics from start/end timestamps
 */
export function calculateRunMetrics(
  startedAt: string,
  finishedAt: string,
  additionalMetrics?: Record<string, number>
): RunMetrics {
  const durationMs = new Date(finishedAt).getTime() - new Date(startedAt).getTime()

  return {
    duration_ms: durationMs,
    ...additionalMetrics,
  }
}

/**
 * Create a minimal artifact output entry
 */
export function createArtifactOutput(
  name: string,
  type: string,
  ref: string,
  options?: {
    size?: number
    checksum?: string
    mimeType?: string
  }
): ArtifactOutput {
  return {
    name,
    type,
    ref,
    size: options?.size,
    checksum: options?.checksum,
    mime_type: options?.mimeType,
  }
}

/**
 * Generate markdown report from manifest
 */
export function generateManifestReport(
  manifest: ArtifactManifest,
  options: ManifestReportOptions = {}
): string {
  const {
    include_inputs = true,
    include_metrics = true,
    include_env = false,
    max_outputs = 100,
  } = options

  const lines: string[] = []

  // Header
  lines.push(`# Job Run Report: ${manifest.job_type}`)
  lines.push('')
  lines.push(`**Run ID:** ${manifest.run_id}`)
  lines.push(`**Status:** ${manifest.status}`)
  lines.push(`**Created:** ${new Date(manifest.created_at).toLocaleString()}`)
  lines.push('')

  // Inputs
  if (include_inputs && manifest.inputs_snapshot_ref) {
    lines.push('## Inputs')
    lines.push('')
    lines.push(`Snapshot: ${manifest.inputs_snapshot_ref}`)
    lines.push('')
  }

  // Outputs
  if (manifest.outputs.length > 0) {
    lines.push('## Outputs')
    lines.push('')

    const outputsToShow = manifest.outputs.slice(0, max_outputs)
    for (const output of outputsToShow) {
      lines.push(`### ${output.name}`)
      lines.push(`- **Type:** ${output.type}`)
      lines.push(`- **Reference:** ${output.ref}`)
      if (output.size) {
        lines.push(`- **Size:** ${formatBytes(output.size)}`)
      }
      if (output.checksum) {
        lines.push(`- **Checksum:** ${output.checksum.substring(0, 16)}...`)
      }
      lines.push('')
    }

    if (manifest.outputs.length > max_outputs) {
      lines.push(`*... and ${manifest.outputs.length - max_outputs} more outputs*`)
      lines.push('')
    }
  }

  // Metrics
  if (include_metrics && Object.keys(manifest.metrics).length > 0) {
    lines.push('## Metrics')
    lines.push('')

    for (const [key, value] of Object.entries(manifest.metrics)) {
      if (value !== undefined) {
        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase())
        lines.push(`- **${formattedKey}:** ${formatMetric(key, value)}`)
      }
    }
    lines.push('')
  }

  // Environment
  if (include_env && Object.keys(manifest.env_fingerprint).length > 0) {
    lines.push('## Environment')
    lines.push('')

    for (const [key, value] of Object.entries(manifest.env_fingerprint)) {
      if (value) {
        lines.push(`- **${key}:** ${value}`)
      }
    }
    lines.push('')
  }

  // Error
  if (manifest.error) {
    lines.push('## Error')
    lines.push('')
    lines.push('```json')
    lines.push(JSON.stringify(manifest.error, null, 2))
    lines.push('```')
    lines.push('')
  }

  // Footer
  lines.push('---')
  lines.push(`*Generated by JobForge v${manifest.tool_versions.jobforge || 'unknown'}*`)

  return lines.join('\n')
}

/**
 * Format bytes to human-readable string
 */
function formatBytes(bytes: number): string {
  if (bytes === 0) return '0 Bytes'
  const k = 1024
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
}

/**
 * Format metric value based on key
 */
function formatMetric(key: string, value: number): string {
  if (key.includes('duration') || key.includes('time')) {
    if (value < 1000) {
      return `${value}ms`
    }
    return `${(value / 1000).toFixed(2)}s`
  }

  if (key.includes('memory') || key.includes('size')) {
    return formatBytes(value)
  }

  if (key.includes('cost')) {
    return `$${value.toFixed(4)}`
  }

  return value.toString()
}
